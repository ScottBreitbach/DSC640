# Reverse order on points per game
bball <- bball[order(bball$PTS, decreasing = FALSE),]
del(bbal)
r(bbal)
remove(bbal)
bbal
head(bball)
row.names(bball)
# set row names to player name
row.names(bball) <- bball$Name
row.names(bball)
head(bball)
bball <- bball[,2:20]
head(bball)
# Store data as a matrix for heatmap
bball_matrix <- data.matrix(bball)
head(bball_matrix)
# Make a heatmap
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = cm.colors(256), scale = 'column',
margins = c(5,10))
# Pick a different color scheme
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = heat.colors(256),  # sets colors to red / yellow
scale = 'column', margins = c(5,10))
cm.colors(10)
# Set your own color scheme
red_colors <- c('#ffd3cd', '#ffc4bc', '#ffb5ab', '#ffa69a', '#ff9789',
'#ff8978', '#ff7a67', '#ff6b56', '#ff5c45', '#ff4d34')
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = red_colors,  # sets colors to assigned colors
scale = 'column', margins = c(5,10))
# Set your own color scheme
red_colors <- c('#ffd3cd', '#ffc4bc', '#ffb5ab', '#ffa69a', '#ff9789',
'#ff8978', '#ff7a67', '2E4BB1', '#ff6b56', '#ff5c45', '#ff4d34')
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = red_colors,  # sets colors to assigned colors
scale = 'column', margins = c(5,10))
# Set your own color scheme
red_colors <- c('#ffd3cd', '#ffc4bc', '#ffb5ab', '#ffa69a', '#ff9789',
'#ff8978', '#ff7a67', '#2E4BB1', '#ff6b56', '#ff5c45', '#ff4d34')
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = red_colors,  # sets colors to assigned colors
scale = 'column', margins = c(5,10))
# Set your own color scheme
red_colors <- c('#ffd3cd', '#ffc4bc', '#ffb5ab', '#ffa69a', '#ff9789',
'#ff8978', '#ff7a67', '#ff6b56', '#ff5c45', '#ff4d34')
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = red_colors,  # sets colors to assigned colors
scale = 'column', margins = c(5,10))
?cm.colors
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = rainbow,  # sets colors to assigned colors
scale = 'column', margins = c(5,10))
red_colors
# Set your own color scheme
red_colors <- c('#ffd3cd', '#ffc4bc', '#ffb5ab', '#ffa69a', '#ff9789',
'#ff8978', '#ff7a67', '#ff6b56', '#ff5c45', '#ff4d34')
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = red_colors,  # sets colors to assigned colors
scale = 'column', margins = c(5,10))
?brewer.pal
??brewer.pal
library(RColorBrewer)
?brewer.pal
# Create a heatmap using ColorBrewer
bball_heatmap <- heatmap(bball_matrix, Rowv = NA, Colv = NA,
col = brewer.pal(9, "Blues"),  # 9 shades of blue
scale = 'column', margins = c(5,10))
# Load library
library(aplpack)
# Load library
install.packages('aplpack')
library(aplpack)
# Load data set
bball <- read.csv("http://datasets.flowingdata.com/ppg2008.csv", header = TRUE)
# Make some Chernoff faces
faces(bball[,2:16], ncolors = 0)
# Make some Chernoff faces
faces(bball[,2:16], ncolors = 5)
# Make some Chernoff faces
faces(bball[,2:16], ncolors = 100)
# Make some Chernoff faces
faces(bball[,2:16], ncolors = 256)
# Make some Chernoff faces
faces(bball[,2:16], ncolors = 0)
# Put names to faces
faces(bball[,2:16], labels = bball$Name)
# Put names to faces
faces(bball[,2:16], ncolors = 0, labels = bball$Name)
# Put names to faces
faces(bball[,2:16], ncolors = 0, labels = bball$Name)
?faces
faces(bball[,2:16], ncolors = 0, labels = bball$Name, face.type = 2)
faces(bball[,2:16], ncolors = 0, labels = bball$Name, face.type = 1)
faces(bball[,2:16], ncolors = 0, labels = bball$Name, print.info = TRUE)
faces(bball[,2:16], ncolors = 0, labels = bball$Name, cex = 8)
faces(bball[,2:16], ncolors = 0, labels = bball$Name, cex = 0.8)
faces(bball[,2:16], ncolors = 0, labels = bball$Name, cex = 1)
# Load data
crime <-
read.csv('http://datasets.flowingdata.com/crimeRatesByState-formatted.csv')
head(crime)
# Create star charts
star(crime)
# Create star charts
stars(crime)
# Set row names to state names
row.names(crime) <- crime$state
crime <- crime[,2:7]
# Star charts
stars(crime, flip.labels = FALSE, key.loc = c(15, 1.5))
# Create star charts
stars(crime)
# Star charts
stars(crime, flip.labels = FALSE, key.loc = c(15, 1.5))
# Align labels and add a key
stars(crime, flip.labels = FALSE, key.loc = c(15, 1.5))
# Variations
# Resturct all data to the top half of the circle
stars(crime, flip.labels = FALSE, key.loc = c(15, 1.5), full = FALSE)
# Nightingale charts
stars(crime, flip.labels = FALSE, key.loc = c(15, 1.5), draw.segments = FALSE)
# Nightingale charts
stars(crime, flip.labels = FALSE, key.loc = c(15, 1.5), draw.segments = TRUE)
# Load data
url <- "http://datasets.flowingdata.com/education.csv"
education <- read.csv(url, header = TRUE)
education[1:10,]
# Load library
library(lattice)
# Create parallel coordinates plot
parallel(education)
# Create parallel coordinates plot
parallelplot(education)
# Flip on axis
parallelplot(education, horizontal.axis=FALSE)
# Remove state column & change colors to black
parallelplot(education[,2:7], horizontal.axis=FALSE, col = '#000000')
summary(education)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#cccccc'
}
reading_colors <- c(reading_colors, col)
}
head(education)
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#737373'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#525252'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#525252'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#737373'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#969696'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#bdbdbd'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#cccccc'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#bdbdbd'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#bdbdbd'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#767676'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
# set colors for each state by greater or less than median reading score
reading_colors <- c()
for (i in 1:length(education$state)) {
if(education$reading[i] >523) {
col <- '#000000'
} else {
col <- '#bdbdbd'
}
reading_colors <- c(reading_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = reading_colors)
for (i in 1:length(education$state)) {
if(education$dropout_rate[i] > 5.3) {
col <- '#000000'
} else {
col <- '#bdbdbd'
}
dropout_colors <- c(dropout_colors, col)
}
# set colors based on dropout rates
dropout_colors <- c()
for (i in 1:length(education$state)) {
if(education$dropout_rate[i] > 5.3) {
col <- '#000000'
} else {
col <- '#bdbdbd'
}
dropout_colors <- c(dropout_colors, col)
}
# Pass the colors in to the parallel function
parallelplot(education[,2:7], horizontal.axis=FALSE, col = dropout_colors)
# Load data
url <- "http://datasets.flowingdata.com/education.csv"
education <- read.csv(url, header = TRUE)
# Figure out how far each state should be from each other
ed.dis <- dist(education[,2:7])
ed.dis
# get x-y coordinates for each state
ed.mds <- cmdscale(ed.dis)
ed.mds
# store these values in x and y variables
x <- ed.mds[,1]
y <- ed.mds[,2]
plot(x, y)
# add labels
plot(x, y, type='n')
text(x, y, labels = education$state)
plot(x, y, type='n')
text(x, y, labels = education$state, col = reading_colors)
plot(x, y, type='n')
text(x, y, labels = education$state, col = dropout_colors)
## Model-based clustering
library(mclust)
ed.mclust <- Mclust(ed.mds)
# plot
plot(ed.mclust, data = ed.mds)
# plot
plot(ed.mclust, data = ed.mds)
# plot
plot(ed.mclust, data = ed.mds)
# plot
plot(ed.mclust, data = ed.mds)
# get x-y coordinates for each state
ed.mds <- cmdscale(ed.dis)
# fit
ed.mclust <- Mclust(ed.mds)
# plot
plot(ed.mclust, data = ed.mds)
# fit
ed.mclust <- Mclust(ed.mds)
# plot
plot(ed.mclust, data = ed.mds)
library(wordcloud)
library(RColorBrewer)
library(wordcloud2)
library(tm)
head(data)
head(data$text)
# Set Working Directory
setwd("C:/Users/micha/OneDrive/Documents/GitHub/DSC640/Weeks11-12/")
t <- read.csv("compiled_words.txt")
t <- read.csv("compiled_words.txt", sep = "\t")
head(t)
names(t)
t <- read.csv("compiled_words.txt", sep = "\t", header = FALSE)
head(t)
names(t)
install.packages("readtext")
library(readtext)
readtext(paste0("compiled_words.txt"))
rt_txt <- readtext(paste0("compiled_words.txt"))
# create quanteda corpus
corpus_txt <- Corpus(rt_txt)
# create quanteda corpus
corpus_txt <- corpus(rt_txt)
# read in text file
rt_txt <- readtext(paste0("compiled_words.txt"), text_field = "texts")
# create quanteda corpus
corpus_txt <- corpus(rt_txt)
# create quanteda corpus
corpus_txt <- Corpus(rt_txt)
rt_txt
?Corpus()
library(corpus)
install.packages("corpus")
# install.packages("corpus")
library(corpus)
# create quanteda corpus
corpus_txt <- corpus(rt_txt)
# create quanteda corpus
corpus_txt <- VCorpus(rt_txt)
Corpus(rt_txt, readerControl = reader)
Corpus("compiled_words.txt")
Corpus(rt_txt,"compiled_words.txt")
VCorpus(VectorSource(t))
corp
corp <- VCorpus(VectorSource(t))
inspect(corp)
inspect(corp[[2]])
inspect(corp[[1]])
inspect(corp[[0]])
inspect(corp[[3]])
inspect(corp[[1]])
# Transformations
# eliminate whitespace
corp2 <- tm_map(corp, stripWhitespace)
corp2
inspect(corp2[[1]])
# convert to lower
corp2 <- tm_map(corp2, content_transformer(tolower))
inspect(corp2[[1]])
# remove stopwords
corp2 <- tm_map(corp2, removeWords, stopwords("english"))
inspect(corp2[[1]])
corp3 <- corp %>%
tm_map(removeNumbers) %>%
tm_map(removePunctuation) %>%
tm_map(stripWhitespace)
corp3 <- tm_map(corp, removeNumbers)
corp3 <- tm_map(corp3, removePunctuation)
corp3 <- tm_map(corp3, stripWhitespace)
corp3 <- tm_map(corp3, content_transformer(tolower))
corp3 <- tm_map(corp3, removeWords, stopwords("english"))
inspect(corp3[[1]])
# Create a document-term-matrix
dtm <- TermDocumentMatrix(corp3)
matrix <- as.matrix(dtm)
words <- sort(rowSums(matrix), decreasing = TRUE)
df <- data.frame(word = names(words), freq=words)
df
# generate wordcloud
wordcloud(words = df$word, freq = df$freq, min.freq = 1,
max.words = 200, random.order = FALSE)
# generate wordcloud
wordcloud(words = df$word, freq = df$freq, min.freq = 1,
max.words = 200, random.order = FALSE,
colors = brewer.pal(8, "Dark2"))
# generate wordcloud
wordcloud(words = df$word, freq = df$freq, min.freq = 1,
max.words = 200, random.order = FALSE,
colors = brewer.pal(10, "Dark2"))
wordcloud2(data = df)
wordcloud2(data = df, size = 1.6, color = 'random-dark')
wordcloud2(data = df, size = 0.7, color = 'random-dark')
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
# Set Working Directory
setwd("C:/Users/micha/OneDrive/Documents/GitHub/DSC640/Weeks11-12/")
# Load libraries
library(ggplot2)
# library(gdata)
library(stringr)  # for converting to title case
library(reshape2) # for melting data
# library(readtext) # for reading text file
library(tm)       # for text cleaning
library(wordcloud2)
# Load data
birthdf <- read.csv('birth-rate.csv')
educadf <- read.csv('education.csv')
eduSummary <- read.csv("education_summary.csv")
# Reshape education data set
edumelt <- melt(educadf[,1:4], id="state")
# Save reformatted education data as CSV for use elsewhere
write.csv(edumelt, "education_melted.csv", row.names = FALSE)
# Rename first column of summarized education data
names(eduSummary)[1] <- 'Category'
# Plot histogram
ggplot(birthdf, aes(x=X1980)) +
geom_histogram(binwidth = 2, fill=color, color="#e9ecef", alpha=0.8) +
xlim(0,60) +
ggtitle('Global Birth Rate Distribution, 1980') +
labs(x="Live Births per 1000 Population", y="Count")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
# Set Working Directory
setwd("C:/Users/micha/OneDrive/Documents/GitHub/DSC640/Weeks11-12/")
# Load libraries
library(ggplot2)
# library(gdata)
library(stringr)  # for converting to title case
library(reshape2) # for melting data
# library(readtext) # for reading text file
library(tm)       # for text cleaning
library(wordcloud2)
# Set color to Bellevue purple
color = "#4f3674"
# Plot histogram
ggplot(birthdf, aes(x=X1980)) +
geom_histogram(binwidth = 2, fill=color, color="#e9ecef", alpha=0.8) +
xlim(0,60) +
ggtitle('Global Birth Rate Distribution, 1980') +
labs(x="Live Births per 1000 Population", y="Count")
# Make box & whisker plot
ggplot(edumelt, aes(x=variable, y=value)) +
geom_boxplot(fill=color, alpha=0.8) +
ggtitle('Distribution of SAT Scores in the United States') +
labs(x="Subject", y="SAT Score")
# Create bullet chart
ggplot(eduSummary, aes(Category, Average)) +
geom_col(fill="#bfaed9", width = 0.5) +
geom_col(fill=color, aes(Category, Actual), width = 0.2) +
geom_errorbar(aes(y = Max, x = Category,
ymin = Max, ymax = Max),
width = 0.45) +
coord_flip() +
ggtitle('Nebraska SAT Scores Compared to US Average and Max Score') +
labs(x="Subject", y="SAT Score")
# Load text data
text <- read.csv("compiled_words.txt", sep = "\t", header = FALSE)
# Create corpus
corp <- VCorpus(VectorSource(text))
# Clean up text data
corp <- tm_map(corp, removeNumbers)
corp <- tm_map(corp, removePunctuation)
corp <- tm_map(corp, stripWhitespace)
corp <- tm_map(corp, content_transformer(tolower))
corp <- tm_map(corp, removeWords, stopwords("english"))
# Create a document-term-matrix
dtm <- TermDocumentMatrix(corp3)
matrix <- as.matrix(dtm)
words <- sort(rowSums(matrix), decreasing = TRUE)
df <- data.frame(word = names(words), freq=words)
# Generate word cloud
wordcloud2(data = df, size = 0.7, color = 'random-dark')
